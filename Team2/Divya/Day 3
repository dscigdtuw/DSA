Move Zeroes

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int count = 0, i = 0;
        while (i < nums.size() - count) {
            if (nums[i] == 0) {
                count++;
                nums.push_back(0);
                nums.erase(nums.begin() + i);
            } else {
                i++;
            }
        }
    }
};

Pivot Index

class Solution {
public:
int pivotIndex(vector& nums) {

    int n=nums.size();
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=nums[i];
    }
    int left=0;
    for(int i=0;i<n;i++)
    {
        sum-=nums[i];
        if(sum==left)
            return i;
        left+=nums[i];
    }
    return -1;
}
};


product of array except self


class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int i,j,pro=1;
        vector<int> pre(nums.size()),suff(nums.size()),output(nums.size());
        for(i=0;i<nums.size();i++){
            pro=pro*nums[i];
            pre[i]=pro;
        }
        pro=1;
        for(i=nums.size()-1;i>=0;i--){
            pro=pro*nums[i];
            suff[i]=pro;
        }
        for(i=0;i<nums.size();i++){
            if(i==0) output[i]=suff[i+1];
            else if(i==nums.size()-1) output[i]=pre[i-1];
            else output[i]=pre[i-1]*suff[i+1];
        }
        return output;
    }
};


Monotonic array

class Solution {
public:
    bool isMonotonic(vector<int>& A) {
        
  
      
        return std::is_sorted(A.begin(), A.end()) || std::is_sorted(A.rbegin(), A.rend());
    
    }
};
